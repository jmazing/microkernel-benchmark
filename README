
# Microkernel vs. Monolithic Kernel Benchmark Suite

This repository provides a comprehensive benchmarking framework to evaluate and compare performance characteristics of **microkernel** (e.g., QNX) and **monolithic kernel** (e.g., Ubuntu) systems. It targets key subsystems like **scheduling**, **IPC**, **memory**, **file systems**, **networking**, and **security**, using both synthetic and real-world-inspired tests.

## ðŸ“ Project Structure

```
src/
â”œâ”€â”€ file_systems/       # Metadata and read/write file system benchmarks
â”œâ”€â”€ ipc/                # Latency benchmarks using pipes and message queues
â”œâ”€â”€ memory/             # malloc/free fragmentation, throughput, leak tests
â”œâ”€â”€ mosquitto/          # MQTT-based pub/sub latency under varied workloads
â”œâ”€â”€ network_and_security/ # Network throughput and system security checks
â”œâ”€â”€ scheduling/         # Thread/process latency, fairness, jitter, inversion
```

## ðŸ”¬ Benchmark Categories

### âœ… Scheduling

* `thread_fairness`, `process_fairness`: Measure fairness in scheduling
* `sleep_wake_thread`, `sleep_wake_process`: Wakeup latency benchmarks
* `deterministic_latency`, `max_latency_scheduling`: Real-time deadline analysis
* `linux_jitter`, `qnx_jitter`: Jitter characterization
* `priority_inversion`: Evaluates priority inheritance handling

### âœ… IPC (Inter-Process Communication)

* `ipc_latency`: Direct pipe-based communication latency
* `ipc_mq_latency`: POSIX message queue round-trip tests
* `ipc_pipe_latency`: Pipe-based round-trips (redundant with `ipc_latency`, if applicable)

### âœ… Memory

* `allocator_throughput`: Measures malloc/free throughput
* `fragment`: Evaluates heap fragmentation
* `malloc`: Stress tests allocator reuse
* `memleak`: Simulates memory leaks for profiling tools

### âœ… File Systems

* `file_meta`: Measures time to create, rename, and delete many small files
* `read`: Sequential read throughput test

### âœ… Real Workload (Mosquitto)

* `burst_pubsub_test`: MQTT burst message latency
* `cpu_load_pubsub_test`: MQTT latency under CPU load
* `qos_sweep_test`: MQTT timing across QoS levels

### âœ… Network and Security

* `network_and_security`: Placeholder for evaluating network throughput and applying basic hardening or permission checks

## ðŸ§ª Building & Running

### Build

```bash
make           # Uses the top-level Makefile
```

### Run Individual Tests

```bash
./bin/thread_fairness
./bin/ipc_latency
./bin/sleep_wake_thread
```

### Launch Benchmarks in VMs (Optional)

```bash
./launch_benchmark_vms_taskset.sh
```

## ðŸ“ˆ Sample Output (Example: IPC Latency)

```
IPC round-trip time (pipe): 21.4 microseconds
IPC round-trip time (message queue): 31.7 microseconds
```

## ðŸ§  Key Takeaways So Far

* **QNX** provides deterministic scheduling with reduced jitter, especially under sporadic and FIFO policies.
* **Ubuntu** handles IPC faster in some cases, likely due to more optimized pipes but less determinism.
* **Heap fragmentation** and **metadata ops** (create/rename/delete) show performance differences based on allocator and file system design.

## ðŸ“š References

* [QNX Neutrino OS Documentation](https://www.qnx.com/developers/docs/)
* [Operating Systems: Three Easy Pieces](https://pages.cs.wisc.edu/~remzi/OSTEP/)
* [Mosquitto MQTT](https://mosquitto.org/)

## ðŸ”— Project Repository

GitHub: [https://github.com/jmazing/microkernel-benchmark](https://github.com/jmazing/microkernel-benchmark)

---

Let me know if you'd like help integrating graphs, logs, or versioned documentation for this suite.


## ðŸ”§ Building and Running Tests

Each test can be compiled using either `gcc` (Linux) or `qcc` (QNX). Mosquitto-based tests require linking against a static `libmosquitto_static` library (provided in `resources/mosquitto/`).

### ðŸ“¦ Compilation Examples

#### Linux (GCC)
```bash
gcc -O2 -o bin/thread_fairness src/scheduling/threads/thread_fairness.c -pthread
gcc -O2 -o bin/ipc_latency src/ipc/ipc_latency.c -lrt -pthread
gcc -O2 -o bin/burst_pubsub_test src/mosquitto/burst_pubsub_test.c \
    resources/mosquitto/libmosquitto_static_linux.a -lrt -pthread
```

#### QNX (QCC)
```bash
qcc -Vgcc_ntox86_64 -o bin/thread_fairness src/scheduling/threads/thread_fairness.c -pthread
qcc -Vgcc_ntox86_64 -o bin/ipc_latency src/ipc/ipc_latency.c -lrt -pthread
qcc -Vgcc_ntox86_64 -o bin/burst_pubsub_test src/mosquitto/burst_pubsub_test.c \
    resources/mosquitto/libmosquitto_static_qnx.a -lrt -pthread
```

> âš ï¸ Ensure you use the correct `libmosquitto_static_*.a` based on platform.

---

### ðŸšš Transferring Binaries to VMs

To run tests inside your virtual machines, you must copy the binaries via `scp`:

#### ðŸ“¤ From Host to QNX VM:
```bash
scp bin/thread_fairness root@192.168.x.x:/tmp/
```

#### ðŸ“¤ From Host to Ubuntu VM:
```bash
scp bin/ipc_latency user@192.168.x.x:/home/user/
```

> âœ… Tip: Ensure your VMs are on bridged or host-only networking to accept `scp` connections.


## ðŸ›  Installing QNX and QCC

### âœ… QNX Installation (VirtualBox ISO)

QNX installation: https://www.qnx.com/developers/docs/8.0/com.qnx.doc.qnxsdp.quickstart/topic/install_host.html

---

### ðŸ§° Installing QCC (QNX Compiler)

1. After booting into QNX, open a terminal or use the system shell.
2. Ensure `/usr/bin/qcc` is in your path:
```bash
export PATH=$PATH:/usr/qnx800/host/linux/x86_64/usr/bin
```
3. Confirm `qcc` is working:
```bash
qcc -Vgcc_ntox86_64
```
You should see compiler version output.

> âœ… Note: If you're compiling from Linux but targeting QNX, install the **QNX SDP on Linux** and build using the QNX-hosted cross-toolchain.
