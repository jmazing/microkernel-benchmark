Here’s the revised `README.md` section with the **"Work in progress"** note removed and the **Network and Security** benchmark included as a finalized category:

---

# Microkernel vs. Monolithic Kernel Benchmark Suite

This repository provides a comprehensive benchmarking framework to evaluate and compare performance characteristics of **microkernel** (e.g., QNX) and **monolithic kernel** (e.g., Ubuntu) systems. It targets key subsystems like **scheduling**, **IPC**, **memory**, **file systems**, **networking**, and **security**, using both synthetic and real-world-inspired tests.

## 📁 Project Structure

```
src/
├── file_systems/       # Metadata and read/write file system benchmarks
├── ipc/                # Latency benchmarks using pipes and message queues
├── memory/             # malloc/free fragmentation, throughput, leak tests
├── mosquitto/          # MQTT-based pub/sub latency under varied workloads
├── network_and_security/ # Network throughput and system security checks
├── scheduling/         # Thread/process latency, fairness, jitter, inversion
```

## 🔬 Benchmark Categories

### ✅ Scheduling

* `thread_fairness`, `process_fairness`: Measure fairness in scheduling
* `sleep_wake_thread`, `sleep_wake_process`: Wakeup latency benchmarks
* `deterministic_latency`, `max_latency_scheduling`: Real-time deadline analysis
* `linux_jitter`, `qnx_jitter`: Jitter characterization
* `priority_inversion`: Evaluates priority inheritance handling

### ✅ IPC (Inter-Process Communication)

* `ipc_latency`: Direct pipe-based communication latency
* `ipc_mq_latency`: POSIX message queue round-trip tests
* `ipc_pipe_latency`: Pipe-based round-trips (redundant with `ipc_latency`, if applicable)

### ✅ Memory

* `allocator_throughput`: Measures malloc/free throughput
* `fragment`: Evaluates heap fragmentation
* `malloc`: Stress tests allocator reuse
* `memleak`: Simulates memory leaks for profiling tools

### ✅ File Systems

* `file_meta`: Measures time to create, rename, and delete many small files
* `read`: Sequential read throughput test

### ✅ Real Workload (Mosquitto)

* `burst_pubsub_test`: MQTT burst message latency
* `cpu_load_pubsub_test`: MQTT latency under CPU load
* `qos_sweep_test`: MQTT timing across QoS levels

### ✅ Network and Security

* `network_and_security`: Placeholder for evaluating network throughput and applying basic hardening or permission checks

## 🧪 Building & Running

### Build

```bash
make           # Uses the top-level Makefile
```

### Run Individual Tests

```bash
./bin/thread_fairness
./bin/ipc_latency
./bin/sleep_wake_thread
```

### Launch Benchmarks in VMs (Optional)

```bash
./launch_benchmark_vms_taskset.sh
```

## 📈 Sample Output (Example: IPC Latency)

```
IPC round-trip time (pipe): 21.4 microseconds
IPC round-trip time (message queue): 31.7 microseconds
```

## 🧠 Key Takeaways So Far

* **QNX** provides deterministic scheduling with reduced jitter, especially under sporadic and FIFO policies.
* **Ubuntu** handles IPC faster in some cases, likely due to more optimized pipes but less determinism.
* **Heap fragmentation** and **metadata ops** (create/rename/delete) show performance differences based on allocator and file system design.

## 📚 References

* [QNX Neutrino OS Documentation](https://www.qnx.com/developers/docs/)
* [Operating Systems: Three Easy Pieces](https://pages.cs.wisc.edu/~remzi/OSTEP/)
* [Mosquitto MQTT](https://mosquitto.org/)

## 🔗 Project Repository

GitHub: [https://github.com/jmazing/microkernel-benchmark](https://github.com/jmazing/microkernel-benchmark)

---

Let me know if you'd like help integrating graphs, logs, or versioned documentation for this suite.
